--[[
    Barren Engine - Integrity Check Module
    Copyright (c) 2025 Barren Engine Contributors
    All rights reserved.

    This software is proprietary and confidential.
    DO NOT EDIT THIS FILE.
]]

local Crypto = require("crypto")
local ffi = require("ffi")

local Integrity = {
    VERSION = "1.0.0",
    BUILD = "20250101",
    CHECKSUM = nil, -- Will be computed on initialization
    
    -- Add timestamp validation settings
    TIMESTAMP_TOLERANCE = 30, -- seconds
    REPLAY_WINDOW = 300,     -- 5 minutes
    
    -- Add to track used nonces
    usedNonces = {},
    lastCleanup = os.time(),
    
    -- Critical files that must match exactly
    CRITICAL_FILES = {
        "init.lua",
        "network/manager.lua",
        "network/connection.lua",
        "network/packet.lua",
        "security/anticheat.lua",
        "security/integrity.lua",
        "crypto.lua"
    },
    
    -- File checksums (computed at runtime)
    FILE_CHECKSUMS = {},
    
    -- Verification states
    State = {
        UNVERIFIED = 0,
        VERIFIED = 1,
        TAMPERED = 2,
        VERSION_MISMATCH = 3,
        CHECKSUM_MISMATCH = 4
    }
}

-- Initialize integrity system
function Integrity.initialize()
    -- Compute checksums for all critical files
    for _, file in ipairs(Integrity.CRITICAL_FILES) do
        local content = Integrity.readFile(file)
        if content then
            Integrity.FILE_CHECKSUMS[file] = Integrity.computeChecksum(content)
        else
            error("Critical file missing: " .. file)
        end
    end
    
    -- Compute overall engine checksum
    local combinedChecksums = ""
    for _, checksum in pairs(Integrity.FILE_CHECKSUMS) do
        combinedChecksums = combinedChecksums .. checksum
    end
    Integrity.CHECKSUM = Integrity.computeChecksum(combinedChecksums)
end

-- Compute secure checksum
function Integrity.computeChecksum(data)
    -- Use our crypto module's SHA-256 implementation
    return Crypto.hash(data)
end

-- Read file contents safely
function Integrity.readFile(filename)
    local file = io.open(filename, "rb")
    if not file then return nil end
    local content = file:read("*all")
    file:close()
    return content
end

-- Create integrity challenge
function Integrity.createChallenge()
    -- Add system-specific entropy
    local entropy = string.format("%s-%s-%s-%s",
        os.time(),
        os.clock() * 1000000,
        collectgarbage("count"),
        tostring({}):match("0x[%x]+")
    )
    
    local challenge = {
        version = Integrity.VERSION,
        build = Integrity.BUILD,
        checksum = Integrity.CHECKSUM,
        timestamp = os.time(),
        nonce = Crypto.randomBytes(32),
        checksums = Integrity.FILE_CHECKSUMS,
        entropy = Crypto.hash(entropy)
    }
    
    -- Sign the challenge with all components
    challenge.signature = Crypto.sign(
        challenge.version .. 
        challenge.build .. 
        challenge.checksum .. 
        challenge.timestamp .. 
        challenge.nonce ..
        challenge.entropy
    )
    
    return challenge
end

-- Verify client response
function Integrity.verifyResponse(challenge, response)
    if not response then
        return Integrity.State.UNVERIFIED, "No response received"
    end
    
    -- Validate timestamp
    local now = os.time()
    local timeDiff = math.abs(now - response.timestamp)
    if timeDiff > Integrity.TIMESTAMP_TOLERANCE then
        return Integrity.State.TAMPERED, 
            string.format("Invalid timestamp: difference of %d seconds", timeDiff)
    end
    
    -- Check for replay attacks
    local nonceKey = Crypto.toHex(response.nonce)
    if Integrity.usedNonces[nonceKey] then
        return Integrity.State.TAMPERED, "Replay attack detected"
    end
    
    -- Store nonce
    Integrity.usedNonces[nonceKey] = now
    
    -- Cleanup old nonces periodically
    if now - Integrity.lastCleanup > 60 then
        Integrity.cleanupNonces()
    end
    
    -- Check version match
    if response.version ~= Integrity.VERSION then
        return Integrity.State.VERSION_MISMATCH,
            string.format("Version mismatch: expected %s, got %s",
                Integrity.VERSION, response.version)
    end
    
    -- Check build match
    if response.build ~= Integrity.BUILD then
        return Integrity.State.VERSION_MISMATCH,
            string.format("Build mismatch: expected %s, got %s",
                Integrity.BUILD, response.build)
    end
    
    -- Verify response signature
    local expectedSignature = Crypto.sign(
        response.version ..
        response.build ..
        response.checksum ..
        challenge.timestamp ..
        challenge.nonce
    )
    
    if response.signature ~= expectedSignature then
        return Integrity.State.TAMPERED, "Invalid response signature"
    end
    
    -- Verify file checksums
    for file, checksum in pairs(Integrity.FILE_CHECKSUMS) do
        if response.checksums[file] ~= checksum then
            return Integrity.State.CHECKSUM_MISMATCH,
                string.format("File checksum mismatch: %s", file)
        end
    end
    
    return Integrity.State.VERIFIED, "Integrity check passed"
end

-- Client-side response to challenge
function Integrity.respondToChallenge(challenge)
    -- Verify the challenge first
    if not challenge.nonce or #challenge.nonce ~= 32 then
        return nil, "Invalid challenge format"
    end
    
    -- Create response
    local response = {
        version = Integrity.VERSION,
        build = Integrity.BUILD,
        checksum = Integrity.CHECKSUM,
        checksums = Integrity.FILE_CHECKSUMS,
        timestamp = challenge.timestamp,
        nonce = challenge.nonce
    }
    
    -- Sign the response
    response.signature = Crypto.sign(
        response.version ..
        response.build ..
        response.checksum ..
        challenge.timestamp ..
        challenge.nonce
    )
    
    return response
end

-- Memory integrity check
function Integrity.verifyMemoryIntegrity()
    local threats = {}
    
    -- Check for debugger
    if Integrity.isDebuggerPresent() then
        table.insert(threats, {
            type = "DEBUGGER_DETECTED",
            details = "Debugger attached to process"
        })
    end
    
    -- Check critical files
    for _, file in ipairs(Integrity.CRITICAL_FILES) do
        local content = Integrity.readFile(file)
        if content then
            local currentChecksum = Integrity.computeChecksum(content)
            if currentChecksum ~= Integrity.FILE_CHECKSUMS[file] then
                -- Validate memory region
                local fileHandle = io.open(file, "rb")
                if fileHandle then
                    local isValid, reason = Integrity.validateMemoryRegion(fileHandle, #content)
                    fileHandle:close()
                    
                    if not isValid then
                        table.insert(threats, {
                            file = file,
                            type = "MEMORY_TAMPERING",
                            details = reason or "Memory region validation failed"
                        })
                    end
                end
                
                table.insert(threats, {
                    file = file,
                    type = "FILE_MODIFIED",
                    details = "File content modified"
                })
            end
        else
            table.insert(threats, {
                file = file,
                type = "FILE_MISSING",
                details = "Critical file missing"
            })
        end
    end
    
    return threats
end

-- Continuous integrity monitoring
function Integrity.startMonitoring(callback)
    local monitor = {
        running = true,
        interval = 5.0, -- seconds
        lastCheck = 0
    }
    
    -- Start monitoring thread
    local function monitorThread()
        while monitor.running do
            local currentTime = os.clock()
            if currentTime - monitor.lastCheck >= monitor.interval then
                local threats = Integrity.verifyMemoryIntegrity()
                if #threats > 0 and callback then
                    callback(threats)
                end
                monitor.lastCheck = currentTime
            end
            -- Prevent busy waiting
            os.execute("sleep 0.1")
        end
    end
    
    -- Start the monitor in a separate thread
    return monitorThread
end

-- Stop integrity monitoring
function Integrity.stopMonitoring(monitor)
    if monitor then
        monitor.running = false
    end
end

-- Add nonce cleanup function
function Integrity.cleanupNonces()
    local now = os.time()
    local cutoff = now - Integrity.REPLAY_WINDOW
    
    -- Cleanup old nonces
    for nonce, timestamp in pairs(Integrity.usedNonces) do
        if timestamp < cutoff then
            Integrity.usedNonces[nonce] = nil
        end
    end
    
    Integrity.lastCleanup = now
end

-- Add function to detect common cheat tools
function Integrity.detectCheatTools()
    local knownTools = {
        "cheatengine-x86_64.exe",
        "x64dbg.exe",
        "ollydbg.exe",
        "ida64.exe",
        "ghidra.exe",
        "process_hacker.exe",
        "wireshark.exe",
        "fiddler.exe"
    }
    
    local threats = {}
    
    -- Check running processes
    local handle = io.popen("tasklist")
    if handle then
        local result = handle:read("*a")
        handle:close()
        
        for _, tool in ipairs(knownTools) do
            if result:lower():find(tool:lower()) then
                table.insert(threats, {
                    type = "CHEAT_TOOL_DETECTED",
                    details = "Detected: " .. tool
                })
            end
        end
    end
    
    return threats
end

-- Add memory validation function
function Integrity.validateMemoryRegion(start, size)
    local ffi = require("ffi")
    
    -- Check memory permissions
    ffi.cdef[[
        typedef struct {
            unsigned long Protect;
            size_t RegionSize;
            unsigned long State;
            unsigned long Type;
        } MEMORY_BASIC_INFORMATION;
        
        size_t VirtualQuery(void* lpAddress, MEMORY_BASIC_INFORMATION* lpBuffer, size_t dwLength);
    ]]
    
    local info = ffi.new("MEMORY_BASIC_INFORMATION")
    local result = ffi.C.VirtualQuery(start, info, ffi.sizeof(info))
    
    if result == 0 then
        return false, "Failed to query memory region"
    end
    
    -- Check for suspicious memory permissions
    if bit.band(info.Protect, 0x40) ~= 0 then -- PAGE_EXECUTE_READWRITE
        return false, "Suspicious memory permissions detected"
    end
    
    return true
end

-- Initialize the integrity system
Integrity.initialize()

return Integrity 